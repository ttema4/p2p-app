#include <string>
#include <unordered_map>

struct Order {
    std::string id; // Строка, будем хранить не фактический id, а фрагмент ссылки?

    // Фактически, без статуса мерчанта на бирже(получить его очень сложно,
    // а потому в MVP уж точно не стоит рассматривать свзки с учетом того,
    // что закупаемся/продаемся мы как мерчант), мы всегда в роли покупателя,
    // только при закупке "покупаем монету за рубли", а при продаже "покупаем
    // ребли за монету". Несмотря на это, чтобы не смешивать ордера, мы будем
    // условно помечать тип ордера как "BUY" или "SELL".
    // |
    // |
    // v 
    std::string type;

    // Валюта, ЗА которую мы ПОКУПАЕМ. На первом шаге связки - условность, 
    // так как в MVP(да и вообще имея на руках только карты российских банков)
    // логично реализовать только свзки с покупкой за рубли.
    // |
    // |
    // v
    std::string coin1;
    std::string coin2; // Валюта, ЗА которую мы ПРОДАЁМ. Аналогично, на последнем шаге всегда рубль.
    long double exchange_rate; // Курс
    std::pair<int, int> range; // Верхняя и нижняя шраница объема закупки
    long double seller_rating; // Рейтинг продавца
};

// !!! Нужно более умное хранение / умная соротировка, чтобы быстро находить ордер по банку/монетам,
// а не проходить каждый раз весь вектор. !!!
std::vector<std::unique_ptr<Order>> orders;

// Обертка для хранения рыночных курсов
class MarketRate{
    // Pair не может быть ключом, нужен либо кастом хэш, либо другое хранение...
    std::unordered_map<std::pair<std::string, std::string>, long double> rates; // Курсы по маркету
};

struct Result {
    // Обертка для хранения уже посчитанных связок в каком то виде
};

class DataReceiver {
    // Получить - разложить в ордера и MarketRate
    // Вытаскиваем из БД? Получаем .json через TCP? Вытаскиваем из очереди Rabbit'а?
};

class Analysis {
    // Здесь все методы для обработки поллученных данных до состояния Result
    // Вытаскиваем order'a(нужно умное хранение в каком то определенном порядке)
    // Проходимся for'ами
    // Складываем в Result в каком то виде Order 1 - Market - Order 2 - Spread
};

class DataSender {
    // Кладем в БД? Отправляем .json через TCP? Кладем в очередь Rabbit'а?
};

int main(){

}